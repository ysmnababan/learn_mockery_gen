// Code generated by mockery. DO NOT EDIT.

package mocks

import (
	abstraction "mockery/abstraction"

	gorm "gorm.io/gorm"

	mock "github.com/stretchr/testify/mock"
)

// AnyRepository is an autogenerated mock type for the AnyRepository type
type AnyRepository struct {
	mock.Mock
}

type AnyRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *AnyRepository) EXPECT() *AnyRepository_Expecter {
	return &AnyRepository_Expecter{mock: &_m.Mock}
}

// Association provides a mock function with given fields: payload, query
func (_m *AnyRepository) Association(payload string, query *gorm.DB) (*gorm.DB, error) {
	ret := _m.Called(payload, query)

	if len(ret) == 0 {
		panic("no return value specified for Association")
	}

	var r0 *gorm.DB
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *gorm.DB) (*gorm.DB, error)); ok {
		return rf(payload, query)
	}
	if rf, ok := ret.Get(0).(func(string, *gorm.DB) *gorm.DB); ok {
		r0 = rf(payload, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gorm.DB) error); ok {
		r1 = rf(payload, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_Association_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Association'
type AnyRepository_Association_Call struct {
	*mock.Call
}

// Association is a helper method to define mock.On call
//   - payload string
//   - query *gorm.DB
func (_e *AnyRepository_Expecter) Association(payload interface{}, query interface{}) *AnyRepository_Association_Call {
	return &AnyRepository_Association_Call{Call: _e.mock.On("Association", payload, query)}
}

func (_c *AnyRepository_Association_Call) Run(run func(payload string, query *gorm.DB)) *AnyRepository_Association_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*gorm.DB))
	})
	return _c
}

func (_c *AnyRepository_Association_Call) Return(_a0 *gorm.DB, _a1 error) *AnyRepository_Association_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_Association_Call) RunAndReturn(run func(string, *gorm.DB) (*gorm.DB, error)) *AnyRepository_Association_Call {
	_c.Call.Return(run)
	return _c
}

// BatchDelete provides a mock function with given fields: ctx, filter, model
func (_m *AnyRepository) BatchDelete(ctx *abstraction.Context, filter abstraction.Anyfilter, model interface{}) (interface{}, error) {
	ret := _m.Called(ctx, filter, model)

	if len(ret) == 0 {
		panic("no return value specified for BatchDelete")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, abstraction.Anyfilter, interface{}) (interface{}, error)); ok {
		return rf(ctx, filter, model)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, abstraction.Anyfilter, interface{}) interface{}); ok {
		r0 = rf(ctx, filter, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, abstraction.Anyfilter, interface{}) error); ok {
		r1 = rf(ctx, filter, model)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_BatchDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchDelete'
type AnyRepository_BatchDelete_Call struct {
	*mock.Call
}

// BatchDelete is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - filter abstraction.Anyfilter
//   - model interface{}
func (_e *AnyRepository_Expecter) BatchDelete(ctx interface{}, filter interface{}, model interface{}) *AnyRepository_BatchDelete_Call {
	return &AnyRepository_BatchDelete_Call{Call: _e.mock.On("BatchDelete", ctx, filter, model)}
}

func (_c *AnyRepository_BatchDelete_Call) Run(run func(ctx *abstraction.Context, filter abstraction.Anyfilter, model interface{})) *AnyRepository_BatchDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(abstraction.Anyfilter), args[2].(interface{}))
	})
	return _c
}

func (_c *AnyRepository_BatchDelete_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_BatchDelete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_BatchDelete_Call) RunAndReturn(run func(*abstraction.Context, abstraction.Anyfilter, interface{}) (interface{}, error)) *AnyRepository_BatchDelete_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function with given fields: ctx, f, model, count
func (_m *AnyRepository) Count(ctx *abstraction.Context, f *abstraction.Query, model interface{}, count *int64) (interface{}, error) {
	ret := _m.Called(ctx, f, model, count)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}, *int64) (interface{}, error)); ok {
		return rf(ctx, f, model, count)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}, *int64) interface{}); ok {
		r0 = rf(ctx, f, model, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, *abstraction.Query, interface{}, *int64) error); ok {
		r1 = rf(ctx, f, model, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type AnyRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - f *abstraction.Query
//   - model interface{}
//   - count *int64
func (_e *AnyRepository_Expecter) Count(ctx interface{}, f interface{}, model interface{}, count interface{}) *AnyRepository_Count_Call {
	return &AnyRepository_Count_Call{Call: _e.mock.On("Count", ctx, f, model, count)}
}

func (_c *AnyRepository_Count_Call) Run(run func(ctx *abstraction.Context, f *abstraction.Query, model interface{}, count *int64)) *AnyRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(*abstraction.Query), args[2].(interface{}), args[3].(*int64))
	})
	return _c
}

func (_c *AnyRepository_Count_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_Count_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_Count_Call) RunAndReturn(run func(*abstraction.Context, *abstraction.Query, interface{}, *int64) (interface{}, error)) *AnyRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function with given fields: ctx, model, opts
func (_m *AnyRepository) Create(ctx *abstraction.Context, model interface{}, opts ...func(*gorm.DB) *gorm.DB) (interface{}, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, model)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, interface{}, ...func(*gorm.DB) *gorm.DB) (interface{}, error)); ok {
		return rf(ctx, model, opts...)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, interface{}, ...func(*gorm.DB) *gorm.DB) interface{}); ok {
		r0 = rf(ctx, model, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, interface{}, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = rf(ctx, model, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type AnyRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - model interface{}
//   - opts ...func(*gorm.DB) *gorm.DB
func (_e *AnyRepository_Expecter) Create(ctx interface{}, model interface{}, opts ...interface{}) *AnyRepository_Create_Call {
	return &AnyRepository_Create_Call{Call: _e.mock.On("Create",
		append([]interface{}{ctx, model}, opts...)...)}
}

func (_c *AnyRepository_Create_Call) Run(run func(ctx *abstraction.Context, model interface{}, opts ...func(*gorm.DB) *gorm.DB)) *AnyRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]func(*gorm.DB) *gorm.DB, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(func(*gorm.DB) *gorm.DB)
			}
		}
		run(args[0].(*abstraction.Context), args[1].(interface{}), variadicArgs...)
	})
	return _c
}

func (_c *AnyRepository_Create_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_Create_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_Create_Call) RunAndReturn(run func(*abstraction.Context, interface{}, ...func(*gorm.DB) *gorm.DB) (interface{}, error)) *AnyRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function with given fields: ctx, model
func (_m *AnyRepository) Delete(ctx *abstraction.Context, model interface{}) (interface{}, error) {
	ret := _m.Called(ctx, model)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, interface{}) (interface{}, error)); ok {
		return rf(ctx, model)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, interface{}) interface{}); ok {
		r0 = rf(ctx, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, interface{}) error); ok {
		r1 = rf(ctx, model)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type AnyRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - model interface{}
func (_e *AnyRepository_Expecter) Delete(ctx interface{}, model interface{}) *AnyRepository_Delete_Call {
	return &AnyRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, model)}
}

func (_c *AnyRepository_Delete_Call) Run(run func(ctx *abstraction.Context, model interface{})) *AnyRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(interface{}))
	})
	return _c
}

func (_c *AnyRepository_Delete_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_Delete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_Delete_Call) RunAndReturn(run func(*abstraction.Context, interface{}) (interface{}, error)) *AnyRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// ExecRawSQL provides a mock function with given fields: ctx, query, args
func (_m *AnyRepository) ExecRawSQL(ctx *abstraction.Context, query string, args ...interface{}) (interface{}, error) {
	var _ca []interface{}
	_ca = append(_ca, ctx, query)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for ExecRawSQL")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, string, ...interface{}) (interface{}, error)); ok {
		return rf(ctx, query, args...)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, string, ...interface{}) interface{}); ok {
		r0 = rf(ctx, query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, string, ...interface{}) error); ok {
		r1 = rf(ctx, query, args...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_ExecRawSQL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecRawSQL'
type AnyRepository_ExecRawSQL_Call struct {
	*mock.Call
}

// ExecRawSQL is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - query string
//   - args ...interface{}
func (_e *AnyRepository_Expecter) ExecRawSQL(ctx interface{}, query interface{}, args ...interface{}) *AnyRepository_ExecRawSQL_Call {
	return &AnyRepository_ExecRawSQL_Call{Call: _e.mock.On("ExecRawSQL",
		append([]interface{}{ctx, query}, args...)...)}
}

func (_c *AnyRepository_ExecRawSQL_Call) Run(run func(ctx *abstraction.Context, query string, args ...interface{})) *AnyRepository_ExecRawSQL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		variadicArgs := make([]interface{}, len(args)-2)
		for i, a := range args[2:] {
			if a != nil {
				variadicArgs[i] = a.(interface{})
			}
		}
		run(args[0].(*abstraction.Context), args[1].(string), variadicArgs...)
	})
	return _c
}

func (_c *AnyRepository_ExecRawSQL_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_ExecRawSQL_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_ExecRawSQL_Call) RunAndReturn(run func(*abstraction.Context, string, ...interface{}) (interface{}, error)) *AnyRepository_ExecRawSQL_Call {
	_c.Call.Return(run)
	return _c
}

// Filter provides a mock function with given fields: payload, query
func (_m *AnyRepository) Filter(payload string, query *gorm.DB) (*gorm.DB, error) {
	ret := _m.Called(payload, query)

	if len(ret) == 0 {
		panic("no return value specified for Filter")
	}

	var r0 *gorm.DB
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *gorm.DB) (*gorm.DB, error)); ok {
		return rf(payload, query)
	}
	if rf, ok := ret.Get(0).(func(string, *gorm.DB) *gorm.DB); ok {
		r0 = rf(payload, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gorm.DB) error); ok {
		r1 = rf(payload, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_Filter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Filter'
type AnyRepository_Filter_Call struct {
	*mock.Call
}

// Filter is a helper method to define mock.On call
//   - payload string
//   - query *gorm.DB
func (_e *AnyRepository_Expecter) Filter(payload interface{}, query interface{}) *AnyRepository_Filter_Call {
	return &AnyRepository_Filter_Call{Call: _e.mock.On("Filter", payload, query)}
}

func (_c *AnyRepository_Filter_Call) Run(run func(payload string, query *gorm.DB)) *AnyRepository_Filter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*gorm.DB))
	})
	return _c
}

func (_c *AnyRepository_Filter_Call) Return(_a0 *gorm.DB, _a1 error) *AnyRepository_Filter_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_Filter_Call) RunAndReturn(run func(string, *gorm.DB) (*gorm.DB, error)) *AnyRepository_Filter_Call {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function with given fields: ctx, f, model
func (_m *AnyRepository) Find(ctx *abstraction.Context, f *abstraction.Query, model interface{}) (*abstraction.PaginationInfo, error) {
	ret := _m.Called(ctx, f, model)

	if len(ret) == 0 {
		panic("no return value specified for Find")
	}

	var r0 *abstraction.PaginationInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}) (*abstraction.PaginationInfo, error)); ok {
		return rf(ctx, f, model)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}) *abstraction.PaginationInfo); ok {
		r0 = rf(ctx, f, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*abstraction.PaginationInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, *abstraction.Query, interface{}) error); ok {
		r1 = rf(ctx, f, model)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type AnyRepository_Find_Call struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - f *abstraction.Query
//   - model interface{}
func (_e *AnyRepository_Expecter) Find(ctx interface{}, f interface{}, model interface{}) *AnyRepository_Find_Call {
	return &AnyRepository_Find_Call{Call: _e.mock.On("Find", ctx, f, model)}
}

func (_c *AnyRepository_Find_Call) Run(run func(ctx *abstraction.Context, f *abstraction.Query, model interface{})) *AnyRepository_Find_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(*abstraction.Query), args[2].(interface{}))
	})
	return _c
}

func (_c *AnyRepository_Find_Call) Return(_a0 *abstraction.PaginationInfo, _a1 error) *AnyRepository_Find_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_Find_Call) RunAndReturn(run func(*abstraction.Context, *abstraction.Query, interface{}) (*abstraction.PaginationInfo, error)) *AnyRepository_Find_Call {
	_c.Call.Return(run)
	return _c
}

// FindById provides a mock function with given fields: ctx, id, f, model
func (_m *AnyRepository) FindById(ctx *abstraction.Context, id int, f *abstraction.Query, model interface{}) (interface{}, error) {
	ret := _m.Called(ctx, id, f, model)

	if len(ret) == 0 {
		panic("no return value specified for FindById")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, int, *abstraction.Query, interface{}) (interface{}, error)); ok {
		return rf(ctx, id, f, model)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, int, *abstraction.Query, interface{}) interface{}); ok {
		r0 = rf(ctx, id, f, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, int, *abstraction.Query, interface{}) error); ok {
		r1 = rf(ctx, id, f, model)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_FindById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindById'
type AnyRepository_FindById_Call struct {
	*mock.Call
}

// FindById is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - id int
//   - f *abstraction.Query
//   - model interface{}
func (_e *AnyRepository_Expecter) FindById(ctx interface{}, id interface{}, f interface{}, model interface{}) *AnyRepository_FindById_Call {
	return &AnyRepository_FindById_Call{Call: _e.mock.On("FindById", ctx, id, f, model)}
}

func (_c *AnyRepository_FindById_Call) Run(run func(ctx *abstraction.Context, id int, f *abstraction.Query, model interface{})) *AnyRepository_FindById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(int), args[2].(*abstraction.Query), args[3].(interface{}))
	})
	return _c
}

func (_c *AnyRepository_FindById_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_FindById_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_FindById_Call) RunAndReturn(run func(*abstraction.Context, int, *abstraction.Query, interface{}) (interface{}, error)) *AnyRepository_FindById_Call {
	_c.Call.Return(run)
	return _c
}

// GetName provides a mock function with given fields: ctx, id
func (_m *AnyRepository) GetName(ctx *abstraction.Context, id int) (string, error) {
	ret := _m.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetName")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, int) (string, error)); ok {
		return rf(ctx, id)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, int) string); ok {
		r0 = rf(ctx, id)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, int) error); ok {
		r1 = rf(ctx, id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_GetName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetName'
type AnyRepository_GetName_Call struct {
	*mock.Call
}

// GetName is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - id int
func (_e *AnyRepository_Expecter) GetName(ctx interface{}, id interface{}) *AnyRepository_GetName_Call {
	return &AnyRepository_GetName_Call{Call: _e.mock.On("GetName", ctx, id)}
}

func (_c *AnyRepository_GetName_Call) Run(run func(ctx *abstraction.Context, id int)) *AnyRepository_GetName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(int))
	})
	return _c
}

func (_c *AnyRepository_GetName_Call) Return(_a0 string, _a1 error) *AnyRepository_GetName_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_GetName_Call) RunAndReturn(run func(*abstraction.Context, int) (string, error)) *AnyRepository_GetName_Call {
	_c.Call.Return(run)
	return _c
}

// HardDelete provides a mock function with given fields: ctx, f, model
func (_m *AnyRepository) HardDelete(ctx *abstraction.Context, f *abstraction.Query, model interface{}) (interface{}, error) {
	ret := _m.Called(ctx, f, model)

	if len(ret) == 0 {
		panic("no return value specified for HardDelete")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}) (interface{}, error)); ok {
		return rf(ctx, f, model)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}) interface{}); ok {
		r0 = rf(ctx, f, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, *abstraction.Query, interface{}) error); ok {
		r1 = rf(ctx, f, model)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_HardDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HardDelete'
type AnyRepository_HardDelete_Call struct {
	*mock.Call
}

// HardDelete is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - f *abstraction.Query
//   - model interface{}
func (_e *AnyRepository_Expecter) HardDelete(ctx interface{}, f interface{}, model interface{}) *AnyRepository_HardDelete_Call {
	return &AnyRepository_HardDelete_Call{Call: _e.mock.On("HardDelete", ctx, f, model)}
}

func (_c *AnyRepository_HardDelete_Call) Run(run func(ctx *abstraction.Context, f *abstraction.Query, model interface{})) *AnyRepository_HardDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(*abstraction.Query), args[2].(interface{}))
	})
	return _c
}

func (_c *AnyRepository_HardDelete_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_HardDelete_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_HardDelete_Call) RunAndReturn(run func(*abstraction.Context, *abstraction.Query, interface{}) (interface{}, error)) *AnyRepository_HardDelete_Call {
	_c.Call.Return(run)
	return _c
}

// Last provides a mock function with given fields: ctx, f, model
func (_m *AnyRepository) Last(ctx *abstraction.Context, f *abstraction.Query, model interface{}) (interface{}, error) {
	ret := _m.Called(ctx, f, model)

	if len(ret) == 0 {
		panic("no return value specified for Last")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}) (interface{}, error)); ok {
		return rf(ctx, f, model)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}) interface{}); ok {
		r0 = rf(ctx, f, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, *abstraction.Query, interface{}) error); ok {
		r1 = rf(ctx, f, model)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_Last_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Last'
type AnyRepository_Last_Call struct {
	*mock.Call
}

// Last is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - f *abstraction.Query
//   - model interface{}
func (_e *AnyRepository_Expecter) Last(ctx interface{}, f interface{}, model interface{}) *AnyRepository_Last_Call {
	return &AnyRepository_Last_Call{Call: _e.mock.On("Last", ctx, f, model)}
}

func (_c *AnyRepository_Last_Call) Run(run func(ctx *abstraction.Context, f *abstraction.Query, model interface{})) *AnyRepository_Last_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(*abstraction.Query), args[2].(interface{}))
	})
	return _c
}

func (_c *AnyRepository_Last_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_Last_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_Last_Call) RunAndReturn(run func(*abstraction.Context, *abstraction.Query, interface{}) (interface{}, error)) *AnyRepository_Last_Call {
	_c.Call.Return(run)
	return _c
}

// LiterallyCount provides a mock function with given fields: ctx, f, m, count
func (_m *AnyRepository) LiterallyCount(ctx *abstraction.Context, f *abstraction.Query, m interface{}, count *int64) (interface{}, error) {
	ret := _m.Called(ctx, f, m, count)

	if len(ret) == 0 {
		panic("no return value specified for LiterallyCount")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}, *int64) (interface{}, error)); ok {
		return rf(ctx, f, m, count)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}, *int64) interface{}); ok {
		r0 = rf(ctx, f, m, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, *abstraction.Query, interface{}, *int64) error); ok {
		r1 = rf(ctx, f, m, count)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_LiterallyCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LiterallyCount'
type AnyRepository_LiterallyCount_Call struct {
	*mock.Call
}

// LiterallyCount is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - f *abstraction.Query
//   - m interface{}
//   - count *int64
func (_e *AnyRepository_Expecter) LiterallyCount(ctx interface{}, f interface{}, m interface{}, count interface{}) *AnyRepository_LiterallyCount_Call {
	return &AnyRepository_LiterallyCount_Call{Call: _e.mock.On("LiterallyCount", ctx, f, m, count)}
}

func (_c *AnyRepository_LiterallyCount_Call) Run(run func(ctx *abstraction.Context, f *abstraction.Query, m interface{}, count *int64)) *AnyRepository_LiterallyCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(*abstraction.Query), args[2].(interface{}), args[3].(*int64))
	})
	return _c
}

func (_c *AnyRepository_LiterallyCount_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_LiterallyCount_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_LiterallyCount_Call) RunAndReturn(run func(*abstraction.Context, *abstraction.Query, interface{}, *int64) (interface{}, error)) *AnyRepository_LiterallyCount_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function with given fields: ctx, model
func (_m *AnyRepository) Save(ctx *abstraction.Context, model interface{}) (interface{}, error) {
	ret := _m.Called(ctx, model)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, interface{}) (interface{}, error)); ok {
		return rf(ctx, model)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, interface{}) interface{}); ok {
		r0 = rf(ctx, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, interface{}) error); ok {
		r1 = rf(ctx, model)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type AnyRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - model interface{}
func (_e *AnyRepository_Expecter) Save(ctx interface{}, model interface{}) *AnyRepository_Save_Call {
	return &AnyRepository_Save_Call{Call: _e.mock.On("Save", ctx, model)}
}

func (_c *AnyRepository_Save_Call) Run(run func(ctx *abstraction.Context, model interface{})) *AnyRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(interface{}))
	})
	return _c
}

func (_c *AnyRepository_Save_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_Save_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_Save_Call) RunAndReturn(run func(*abstraction.Context, interface{}) (interface{}, error)) *AnyRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// SetNil provides a mock function with given fields: ctx, model, column
func (_m *AnyRepository) SetNil(ctx *abstraction.Context, model interface{}, column string) (interface{}, error) {
	ret := _m.Called(ctx, model, column)

	if len(ret) == 0 {
		panic("no return value specified for SetNil")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, interface{}, string) (interface{}, error)); ok {
		return rf(ctx, model, column)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, interface{}, string) interface{}); ok {
		r0 = rf(ctx, model, column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, interface{}, string) error); ok {
		r1 = rf(ctx, model, column)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_SetNil_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNil'
type AnyRepository_SetNil_Call struct {
	*mock.Call
}

// SetNil is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - model interface{}
//   - column string
func (_e *AnyRepository_Expecter) SetNil(ctx interface{}, model interface{}, column interface{}) *AnyRepository_SetNil_Call {
	return &AnyRepository_SetNil_Call{Call: _e.mock.On("SetNil", ctx, model, column)}
}

func (_c *AnyRepository_SetNil_Call) Run(run func(ctx *abstraction.Context, model interface{}, column string)) *AnyRepository_SetNil_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(interface{}), args[2].(string))
	})
	return _c
}

func (_c *AnyRepository_SetNil_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_SetNil_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_SetNil_Call) RunAndReturn(run func(*abstraction.Context, interface{}, string) (interface{}, error)) *AnyRepository_SetNil_Call {
	_c.Call.Return(run)
	return _c
}

// UnscopedAssociation provides a mock function with given fields: payload, query
func (_m *AnyRepository) UnscopedAssociation(payload string, query *gorm.DB) (*gorm.DB, error) {
	ret := _m.Called(payload, query)

	if len(ret) == 0 {
		panic("no return value specified for UnscopedAssociation")
	}

	var r0 *gorm.DB
	var r1 error
	if rf, ok := ret.Get(0).(func(string, *gorm.DB) (*gorm.DB, error)); ok {
		return rf(payload, query)
	}
	if rf, ok := ret.Get(0).(func(string, *gorm.DB) *gorm.DB); ok {
		r0 = rf(payload, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}

	if rf, ok := ret.Get(1).(func(string, *gorm.DB) error); ok {
		r1 = rf(payload, query)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_UnscopedAssociation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnscopedAssociation'
type AnyRepository_UnscopedAssociation_Call struct {
	*mock.Call
}

// UnscopedAssociation is a helper method to define mock.On call
//   - payload string
//   - query *gorm.DB
func (_e *AnyRepository_Expecter) UnscopedAssociation(payload interface{}, query interface{}) *AnyRepository_UnscopedAssociation_Call {
	return &AnyRepository_UnscopedAssociation_Call{Call: _e.mock.On("UnscopedAssociation", payload, query)}
}

func (_c *AnyRepository_UnscopedAssociation_Call) Run(run func(payload string, query *gorm.DB)) *AnyRepository_UnscopedAssociation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*gorm.DB))
	})
	return _c
}

func (_c *AnyRepository_UnscopedAssociation_Call) Return(_a0 *gorm.DB, _a1 error) *AnyRepository_UnscopedAssociation_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_UnscopedAssociation_Call) RunAndReturn(run func(string, *gorm.DB) (*gorm.DB, error)) *AnyRepository_UnscopedAssociation_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function with given fields: ctx, id, model
func (_m *AnyRepository) Update(ctx *abstraction.Context, id int, model interface{}) (interface{}, error) {
	ret := _m.Called(ctx, id, model)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(*abstraction.Context, int, interface{}) (interface{}, error)); ok {
		return rf(ctx, id, model)
	}
	if rf, ok := ret.Get(0).(func(*abstraction.Context, int, interface{}) interface{}); ok {
		r0 = rf(ctx, id, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(*abstraction.Context, int, interface{}) error); ok {
		r1 = rf(ctx, id, model)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnyRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type AnyRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - id int
//   - model interface{}
func (_e *AnyRepository_Expecter) Update(ctx interface{}, id interface{}, model interface{}) *AnyRepository_Update_Call {
	return &AnyRepository_Update_Call{Call: _e.mock.On("Update", ctx, id, model)}
}

func (_c *AnyRepository_Update_Call) Run(run func(ctx *abstraction.Context, id int, model interface{})) *AnyRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*abstraction.Context), args[1].(int), args[2].(interface{}))
	})
	return _c
}

func (_c *AnyRepository_Update_Call) Return(_a0 interface{}, _a1 error) *AnyRepository_Update_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *AnyRepository_Update_Call) RunAndReturn(run func(*abstraction.Context, int, interface{}) (interface{}, error)) *AnyRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}

// NewAnyRepository creates a new instance of AnyRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewAnyRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *AnyRepository {
	mock := &AnyRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
