// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package repository

import (
	"mockery/abstraction"

	mock "github.com/stretchr/testify/mock"
	"gorm.io/gorm"
)

// NewMockAnyRepository creates a new instance of MockAnyRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAnyRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAnyRepository {
	mock := &MockAnyRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAnyRepository is an autogenerated mock type for the AnyRepository type
type MockAnyRepository struct {
	mock.Mock
}

type MockAnyRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAnyRepository) EXPECT() *MockAnyRepository_Expecter {
	return &MockAnyRepository_Expecter{mock: &_m.Mock}
}

// Association provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) Association(payload string, query *gorm.DB) (*gorm.DB, error) {
	ret := _mock.Called(payload, query)

	if len(ret) == 0 {
		panic("no return value specified for Association")
	}

	var r0 *gorm.DB
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, *gorm.DB) (*gorm.DB, error)); ok {
		return returnFunc(payload, query)
	}
	if returnFunc, ok := ret.Get(0).(func(string, *gorm.DB) *gorm.DB); ok {
		r0 = returnFunc(payload, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, *gorm.DB) error); ok {
		r1 = returnFunc(payload, query)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_Association_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Association'
type MockAnyRepository_Association_Call struct {
	*mock.Call
}

// Association is a helper method to define mock.On call
//   - payload string
//   - query *gorm.DB
func (_e *MockAnyRepository_Expecter) Association(payload interface{}, query interface{}) *MockAnyRepository_Association_Call {
	return &MockAnyRepository_Association_Call{Call: _e.mock.On("Association", payload, query)}
}

func (_c *MockAnyRepository_Association_Call) Run(run func(payload string, query *gorm.DB)) *MockAnyRepository_Association_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAnyRepository_Association_Call) Return(dB *gorm.DB, err error) *MockAnyRepository_Association_Call {
	_c.Call.Return(dB, err)
	return _c
}

func (_c *MockAnyRepository_Association_Call) RunAndReturn(run func(payload string, query *gorm.DB) (*gorm.DB, error)) *MockAnyRepository_Association_Call {
	_c.Call.Return(run)
	return _c
}

// BatchDelete provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) BatchDelete(ctx *abstraction.Context, filter abstraction.Anyfilter, model any) (any, error) {
	ret := _mock.Called(ctx, filter, model)

	if len(ret) == 0 {
		panic("no return value specified for BatchDelete")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, abstraction.Anyfilter, any) (any, error)); ok {
		return returnFunc(ctx, filter, model)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, abstraction.Anyfilter, any) any); ok {
		r0 = returnFunc(ctx, filter, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, abstraction.Anyfilter, any) error); ok {
		r1 = returnFunc(ctx, filter, model)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_BatchDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'BatchDelete'
type MockAnyRepository_BatchDelete_Call struct {
	*mock.Call
}

// BatchDelete is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - filter abstraction.Anyfilter
//   - model any
func (_e *MockAnyRepository_Expecter) BatchDelete(ctx interface{}, filter interface{}, model interface{}) *MockAnyRepository_BatchDelete_Call {
	return &MockAnyRepository_BatchDelete_Call{Call: _e.mock.On("BatchDelete", ctx, filter, model)}
}

func (_c *MockAnyRepository_BatchDelete_Call) Run(run func(ctx *abstraction.Context, filter abstraction.Anyfilter, model any)) *MockAnyRepository_BatchDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 abstraction.Anyfilter
		if args[1] != nil {
			arg1 = args[1].(abstraction.Anyfilter)
		}
		var arg2 any
		if args[2] != nil {
			arg2 = args[2].(any)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAnyRepository_BatchDelete_Call) Return(v any, err error) *MockAnyRepository_BatchDelete_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_BatchDelete_Call) RunAndReturn(run func(ctx *abstraction.Context, filter abstraction.Anyfilter, model any) (any, error)) *MockAnyRepository_BatchDelete_Call {
	_c.Call.Return(run)
	return _c
}

// Count provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) Count(ctx *abstraction.Context, f *abstraction.Query, model any, count *int64) (any, error) {
	ret := _mock.Called(ctx, f, model, count)

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, any, *int64) (any, error)); ok {
		return returnFunc(ctx, f, model, count)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, any, *int64) any); ok {
		r0 = returnFunc(ctx, f, model, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, *abstraction.Query, any, *int64) error); ok {
		r1 = returnFunc(ctx, f, model, count)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_Count_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Count'
type MockAnyRepository_Count_Call struct {
	*mock.Call
}

// Count is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - f *abstraction.Query
//   - model any
//   - count *int64
func (_e *MockAnyRepository_Expecter) Count(ctx interface{}, f interface{}, model interface{}, count interface{}) *MockAnyRepository_Count_Call {
	return &MockAnyRepository_Count_Call{Call: _e.mock.On("Count", ctx, f, model, count)}
}

func (_c *MockAnyRepository_Count_Call) Run(run func(ctx *abstraction.Context, f *abstraction.Query, model any, count *int64)) *MockAnyRepository_Count_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 *abstraction.Query
		if args[1] != nil {
			arg1 = args[1].(*abstraction.Query)
		}
		var arg2 any
		if args[2] != nil {
			arg2 = args[2].(any)
		}
		var arg3 *int64
		if args[3] != nil {
			arg3 = args[3].(*int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockAnyRepository_Count_Call) Return(v any, err error) *MockAnyRepository_Count_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_Count_Call) RunAndReturn(run func(ctx *abstraction.Context, f *abstraction.Query, model any, count *int64) (any, error)) *MockAnyRepository_Count_Call {
	_c.Call.Return(run)
	return _c
}

// Create provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) Create(ctx *abstraction.Context, model any, opts ...func(*gorm.DB) *gorm.DB) (any, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, model, opts)
	} else {
		tmpRet = _mock.Called(ctx, model)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, any, ...func(*gorm.DB) *gorm.DB) (any, error)); ok {
		return returnFunc(ctx, model, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, any, ...func(*gorm.DB) *gorm.DB) any); ok {
		r0 = returnFunc(ctx, model, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, any, ...func(*gorm.DB) *gorm.DB) error); ok {
		r1 = returnFunc(ctx, model, opts...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_Create_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Create'
type MockAnyRepository_Create_Call struct {
	*mock.Call
}

// Create is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - model any
//   - opts ...func(*gorm.DB) *gorm.DB
func (_e *MockAnyRepository_Expecter) Create(ctx interface{}, model interface{}, opts ...interface{}) *MockAnyRepository_Create_Call {
	return &MockAnyRepository_Create_Call{Call: _e.mock.On("Create",
		append([]interface{}{ctx, model}, opts...)...)}
}

func (_c *MockAnyRepository_Create_Call) Run(run func(ctx *abstraction.Context, model any, opts ...func(*gorm.DB) *gorm.DB)) *MockAnyRepository_Create_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 any
		if args[1] != nil {
			arg1 = args[1].(any)
		}
		var arg2 []func(*gorm.DB) *gorm.DB
		var variadicArgs []func(*gorm.DB) *gorm.DB
		if len(args) > 2 {
			variadicArgs = args[2].([]func(*gorm.DB) *gorm.DB)
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAnyRepository_Create_Call) Return(v any, err error) *MockAnyRepository_Create_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_Create_Call) RunAndReturn(run func(ctx *abstraction.Context, model any, opts ...func(*gorm.DB) *gorm.DB) (any, error)) *MockAnyRepository_Create_Call {
	_c.Call.Return(run)
	return _c
}

// Delete provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) Delete(ctx *abstraction.Context, model any) (any, error) {
	ret := _mock.Called(ctx, model)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, any) (any, error)); ok {
		return returnFunc(ctx, model)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, any) any); ok {
		r0 = returnFunc(ctx, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, any) error); ok {
		r1 = returnFunc(ctx, model)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_Delete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Delete'
type MockAnyRepository_Delete_Call struct {
	*mock.Call
}

// Delete is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - model any
func (_e *MockAnyRepository_Expecter) Delete(ctx interface{}, model interface{}) *MockAnyRepository_Delete_Call {
	return &MockAnyRepository_Delete_Call{Call: _e.mock.On("Delete", ctx, model)}
}

func (_c *MockAnyRepository_Delete_Call) Run(run func(ctx *abstraction.Context, model any)) *MockAnyRepository_Delete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 any
		if args[1] != nil {
			arg1 = args[1].(any)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAnyRepository_Delete_Call) Return(v any, err error) *MockAnyRepository_Delete_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_Delete_Call) RunAndReturn(run func(ctx *abstraction.Context, model any) (any, error)) *MockAnyRepository_Delete_Call {
	_c.Call.Return(run)
	return _c
}

// ExecRawSQL provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) ExecRawSQL(ctx *abstraction.Context, query string, args ...interface{}) (any, error) {
	var tmpRet mock.Arguments
	if len(args) > 0 {
		tmpRet = _mock.Called(ctx, query, args)
	} else {
		tmpRet = _mock.Called(ctx, query)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ExecRawSQL")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, string, ...interface{}) (any, error)); ok {
		return returnFunc(ctx, query, args...)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, string, ...interface{}) any); ok {
		r0 = returnFunc(ctx, query, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, string, ...interface{}) error); ok {
		r1 = returnFunc(ctx, query, args...)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_ExecRawSQL_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ExecRawSQL'
type MockAnyRepository_ExecRawSQL_Call struct {
	*mock.Call
}

// ExecRawSQL is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - query string
//   - args ...interface{}
func (_e *MockAnyRepository_Expecter) ExecRawSQL(ctx interface{}, query interface{}, args ...interface{}) *MockAnyRepository_ExecRawSQL_Call {
	return &MockAnyRepository_ExecRawSQL_Call{Call: _e.mock.On("ExecRawSQL",
		append([]interface{}{ctx, query}, args...)...)}
}

func (_c *MockAnyRepository_ExecRawSQL_Call) Run(run func(ctx *abstraction.Context, query string, args ...interface{})) *MockAnyRepository_ExecRawSQL_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 []interface{}
		var variadicArgs []interface{}
		if len(args) > 2 {
			variadicArgs = args[2].([]interface{})
		}
		arg2 = variadicArgs
		run(
			arg0,
			arg1,
			arg2...,
		)
	})
	return _c
}

func (_c *MockAnyRepository_ExecRawSQL_Call) Return(v any, err error) *MockAnyRepository_ExecRawSQL_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_ExecRawSQL_Call) RunAndReturn(run func(ctx *abstraction.Context, query string, args ...interface{}) (any, error)) *MockAnyRepository_ExecRawSQL_Call {
	_c.Call.Return(run)
	return _c
}

// Filter provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) Filter(payload string, query *gorm.DB) (*gorm.DB, error) {
	ret := _mock.Called(payload, query)

	if len(ret) == 0 {
		panic("no return value specified for Filter")
	}

	var r0 *gorm.DB
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, *gorm.DB) (*gorm.DB, error)); ok {
		return returnFunc(payload, query)
	}
	if returnFunc, ok := ret.Get(0).(func(string, *gorm.DB) *gorm.DB); ok {
		r0 = returnFunc(payload, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, *gorm.DB) error); ok {
		r1 = returnFunc(payload, query)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_Filter_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Filter'
type MockAnyRepository_Filter_Call struct {
	*mock.Call
}

// Filter is a helper method to define mock.On call
//   - payload string
//   - query *gorm.DB
func (_e *MockAnyRepository_Expecter) Filter(payload interface{}, query interface{}) *MockAnyRepository_Filter_Call {
	return &MockAnyRepository_Filter_Call{Call: _e.mock.On("Filter", payload, query)}
}

func (_c *MockAnyRepository_Filter_Call) Run(run func(payload string, query *gorm.DB)) *MockAnyRepository_Filter_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAnyRepository_Filter_Call) Return(dB *gorm.DB, err error) *MockAnyRepository_Filter_Call {
	_c.Call.Return(dB, err)
	return _c
}

func (_c *MockAnyRepository_Filter_Call) RunAndReturn(run func(payload string, query *gorm.DB) (*gorm.DB, error)) *MockAnyRepository_Filter_Call {
	_c.Call.Return(run)
	return _c
}

// Find provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) Find(ctx *abstraction.Context, f *abstraction.Query, model interface{}) (*abstraction.PaginationInfo, error) {
	ret := _mock.Called(ctx, f, model)

	if len(ret) == 0 {
		panic("no return value specified for Find")
	}

	var r0 *abstraction.PaginationInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}) (*abstraction.PaginationInfo, error)); ok {
		return returnFunc(ctx, f, model)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, interface{}) *abstraction.PaginationInfo); ok {
		r0 = returnFunc(ctx, f, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*abstraction.PaginationInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, *abstraction.Query, interface{}) error); ok {
		r1 = returnFunc(ctx, f, model)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_Find_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Find'
type MockAnyRepository_Find_Call struct {
	*mock.Call
}

// Find is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - f *abstraction.Query
//   - model interface{}
func (_e *MockAnyRepository_Expecter) Find(ctx interface{}, f interface{}, model interface{}) *MockAnyRepository_Find_Call {
	return &MockAnyRepository_Find_Call{Call: _e.mock.On("Find", ctx, f, model)}
}

func (_c *MockAnyRepository_Find_Call) Run(run func(ctx *abstraction.Context, f *abstraction.Query, model interface{})) *MockAnyRepository_Find_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 *abstraction.Query
		if args[1] != nil {
			arg1 = args[1].(*abstraction.Query)
		}
		var arg2 interface{}
		if args[2] != nil {
			arg2 = args[2].(interface{})
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAnyRepository_Find_Call) Return(paginationInfo *abstraction.PaginationInfo, err error) *MockAnyRepository_Find_Call {
	_c.Call.Return(paginationInfo, err)
	return _c
}

func (_c *MockAnyRepository_Find_Call) RunAndReturn(run func(ctx *abstraction.Context, f *abstraction.Query, model interface{}) (*abstraction.PaginationInfo, error)) *MockAnyRepository_Find_Call {
	_c.Call.Return(run)
	return _c
}

// FindById provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) FindById(ctx *abstraction.Context, id int, f *abstraction.Query, model any) (any, error) {
	ret := _mock.Called(ctx, id, f, model)

	if len(ret) == 0 {
		panic("no return value specified for FindById")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, int, *abstraction.Query, any) (any, error)); ok {
		return returnFunc(ctx, id, f, model)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, int, *abstraction.Query, any) any); ok {
		r0 = returnFunc(ctx, id, f, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, int, *abstraction.Query, any) error); ok {
		r1 = returnFunc(ctx, id, f, model)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_FindById_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FindById'
type MockAnyRepository_FindById_Call struct {
	*mock.Call
}

// FindById is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - id int
//   - f *abstraction.Query
//   - model any
func (_e *MockAnyRepository_Expecter) FindById(ctx interface{}, id interface{}, f interface{}, model interface{}) *MockAnyRepository_FindById_Call {
	return &MockAnyRepository_FindById_Call{Call: _e.mock.On("FindById", ctx, id, f, model)}
}

func (_c *MockAnyRepository_FindById_Call) Run(run func(ctx *abstraction.Context, id int, f *abstraction.Query, model any)) *MockAnyRepository_FindById_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 *abstraction.Query
		if args[2] != nil {
			arg2 = args[2].(*abstraction.Query)
		}
		var arg3 any
		if args[3] != nil {
			arg3 = args[3].(any)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockAnyRepository_FindById_Call) Return(v any, err error) *MockAnyRepository_FindById_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_FindById_Call) RunAndReturn(run func(ctx *abstraction.Context, id int, f *abstraction.Query, model any) (any, error)) *MockAnyRepository_FindById_Call {
	_c.Call.Return(run)
	return _c
}

// GetName provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) GetName(ctx *abstraction.Context, id int) (string, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetName")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, int) (string, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, int) string); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, int) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_GetName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetName'
type MockAnyRepository_GetName_Call struct {
	*mock.Call
}

// GetName is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - id int
func (_e *MockAnyRepository_Expecter) GetName(ctx interface{}, id interface{}) *MockAnyRepository_GetName_Call {
	return &MockAnyRepository_GetName_Call{Call: _e.mock.On("GetName", ctx, id)}
}

func (_c *MockAnyRepository_GetName_Call) Run(run func(ctx *abstraction.Context, id int)) *MockAnyRepository_GetName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAnyRepository_GetName_Call) Return(s string, err error) *MockAnyRepository_GetName_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockAnyRepository_GetName_Call) RunAndReturn(run func(ctx *abstraction.Context, id int) (string, error)) *MockAnyRepository_GetName_Call {
	_c.Call.Return(run)
	return _c
}

// HardDelete provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) HardDelete(ctx *abstraction.Context, f *abstraction.Query, model any) (any, error) {
	ret := _mock.Called(ctx, f, model)

	if len(ret) == 0 {
		panic("no return value specified for HardDelete")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, any) (any, error)); ok {
		return returnFunc(ctx, f, model)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, any) any); ok {
		r0 = returnFunc(ctx, f, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, *abstraction.Query, any) error); ok {
		r1 = returnFunc(ctx, f, model)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_HardDelete_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'HardDelete'
type MockAnyRepository_HardDelete_Call struct {
	*mock.Call
}

// HardDelete is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - f *abstraction.Query
//   - model any
func (_e *MockAnyRepository_Expecter) HardDelete(ctx interface{}, f interface{}, model interface{}) *MockAnyRepository_HardDelete_Call {
	return &MockAnyRepository_HardDelete_Call{Call: _e.mock.On("HardDelete", ctx, f, model)}
}

func (_c *MockAnyRepository_HardDelete_Call) Run(run func(ctx *abstraction.Context, f *abstraction.Query, model any)) *MockAnyRepository_HardDelete_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 *abstraction.Query
		if args[1] != nil {
			arg1 = args[1].(*abstraction.Query)
		}
		var arg2 any
		if args[2] != nil {
			arg2 = args[2].(any)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAnyRepository_HardDelete_Call) Return(v any, err error) *MockAnyRepository_HardDelete_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_HardDelete_Call) RunAndReturn(run func(ctx *abstraction.Context, f *abstraction.Query, model any) (any, error)) *MockAnyRepository_HardDelete_Call {
	_c.Call.Return(run)
	return _c
}

// Last provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) Last(ctx *abstraction.Context, f *abstraction.Query, model any) (any, error) {
	ret := _mock.Called(ctx, f, model)

	if len(ret) == 0 {
		panic("no return value specified for Last")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, any) (any, error)); ok {
		return returnFunc(ctx, f, model)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, any) any); ok {
		r0 = returnFunc(ctx, f, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, *abstraction.Query, any) error); ok {
		r1 = returnFunc(ctx, f, model)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_Last_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Last'
type MockAnyRepository_Last_Call struct {
	*mock.Call
}

// Last is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - f *abstraction.Query
//   - model any
func (_e *MockAnyRepository_Expecter) Last(ctx interface{}, f interface{}, model interface{}) *MockAnyRepository_Last_Call {
	return &MockAnyRepository_Last_Call{Call: _e.mock.On("Last", ctx, f, model)}
}

func (_c *MockAnyRepository_Last_Call) Run(run func(ctx *abstraction.Context, f *abstraction.Query, model any)) *MockAnyRepository_Last_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 *abstraction.Query
		if args[1] != nil {
			arg1 = args[1].(*abstraction.Query)
		}
		var arg2 any
		if args[2] != nil {
			arg2 = args[2].(any)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAnyRepository_Last_Call) Return(v any, err error) *MockAnyRepository_Last_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_Last_Call) RunAndReturn(run func(ctx *abstraction.Context, f *abstraction.Query, model any) (any, error)) *MockAnyRepository_Last_Call {
	_c.Call.Return(run)
	return _c
}

// LiterallyCount provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) LiterallyCount(ctx *abstraction.Context, f *abstraction.Query, m any, count *int64) (any, error) {
	ret := _mock.Called(ctx, f, m, count)

	if len(ret) == 0 {
		panic("no return value specified for LiterallyCount")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, any, *int64) (any, error)); ok {
		return returnFunc(ctx, f, m, count)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, *abstraction.Query, any, *int64) any); ok {
		r0 = returnFunc(ctx, f, m, count)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, *abstraction.Query, any, *int64) error); ok {
		r1 = returnFunc(ctx, f, m, count)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_LiterallyCount_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'LiterallyCount'
type MockAnyRepository_LiterallyCount_Call struct {
	*mock.Call
}

// LiterallyCount is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - f *abstraction.Query
//   - m any
//   - count *int64
func (_e *MockAnyRepository_Expecter) LiterallyCount(ctx interface{}, f interface{}, m interface{}, count interface{}) *MockAnyRepository_LiterallyCount_Call {
	return &MockAnyRepository_LiterallyCount_Call{Call: _e.mock.On("LiterallyCount", ctx, f, m, count)}
}

func (_c *MockAnyRepository_LiterallyCount_Call) Run(run func(ctx *abstraction.Context, f *abstraction.Query, m any, count *int64)) *MockAnyRepository_LiterallyCount_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 *abstraction.Query
		if args[1] != nil {
			arg1 = args[1].(*abstraction.Query)
		}
		var arg2 any
		if args[2] != nil {
			arg2 = args[2].(any)
		}
		var arg3 *int64
		if args[3] != nil {
			arg3 = args[3].(*int64)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
		)
	})
	return _c
}

func (_c *MockAnyRepository_LiterallyCount_Call) Return(v any, err error) *MockAnyRepository_LiterallyCount_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_LiterallyCount_Call) RunAndReturn(run func(ctx *abstraction.Context, f *abstraction.Query, m any, count *int64) (any, error)) *MockAnyRepository_LiterallyCount_Call {
	_c.Call.Return(run)
	return _c
}

// Save provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) Save(ctx *abstraction.Context, model any) (any, error) {
	ret := _mock.Called(ctx, model)

	if len(ret) == 0 {
		panic("no return value specified for Save")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, any) (any, error)); ok {
		return returnFunc(ctx, model)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, any) any); ok {
		r0 = returnFunc(ctx, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, any) error); ok {
		r1 = returnFunc(ctx, model)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_Save_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Save'
type MockAnyRepository_Save_Call struct {
	*mock.Call
}

// Save is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - model any
func (_e *MockAnyRepository_Expecter) Save(ctx interface{}, model interface{}) *MockAnyRepository_Save_Call {
	return &MockAnyRepository_Save_Call{Call: _e.mock.On("Save", ctx, model)}
}

func (_c *MockAnyRepository_Save_Call) Run(run func(ctx *abstraction.Context, model any)) *MockAnyRepository_Save_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 any
		if args[1] != nil {
			arg1 = args[1].(any)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAnyRepository_Save_Call) Return(v any, err error) *MockAnyRepository_Save_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_Save_Call) RunAndReturn(run func(ctx *abstraction.Context, model any) (any, error)) *MockAnyRepository_Save_Call {
	_c.Call.Return(run)
	return _c
}

// SetNil provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) SetNil(ctx *abstraction.Context, model any, column string) (any, error) {
	ret := _mock.Called(ctx, model, column)

	if len(ret) == 0 {
		panic("no return value specified for SetNil")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, any, string) (any, error)); ok {
		return returnFunc(ctx, model, column)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, any, string) any); ok {
		r0 = returnFunc(ctx, model, column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, any, string) error); ok {
		r1 = returnFunc(ctx, model, column)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_SetNil_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SetNil'
type MockAnyRepository_SetNil_Call struct {
	*mock.Call
}

// SetNil is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - model any
//   - column string
func (_e *MockAnyRepository_Expecter) SetNil(ctx interface{}, model interface{}, column interface{}) *MockAnyRepository_SetNil_Call {
	return &MockAnyRepository_SetNil_Call{Call: _e.mock.On("SetNil", ctx, model, column)}
}

func (_c *MockAnyRepository_SetNil_Call) Run(run func(ctx *abstraction.Context, model any, column string)) *MockAnyRepository_SetNil_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 any
		if args[1] != nil {
			arg1 = args[1].(any)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAnyRepository_SetNil_Call) Return(v any, err error) *MockAnyRepository_SetNil_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_SetNil_Call) RunAndReturn(run func(ctx *abstraction.Context, model any, column string) (any, error)) *MockAnyRepository_SetNil_Call {
	_c.Call.Return(run)
	return _c
}

// UnscopedAssociation provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) UnscopedAssociation(payload string, query *gorm.DB) (*gorm.DB, error) {
	ret := _mock.Called(payload, query)

	if len(ret) == 0 {
		panic("no return value specified for UnscopedAssociation")
	}

	var r0 *gorm.DB
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(string, *gorm.DB) (*gorm.DB, error)); ok {
		return returnFunc(payload, query)
	}
	if returnFunc, ok := ret.Get(0).(func(string, *gorm.DB) *gorm.DB); ok {
		r0 = returnFunc(payload, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*gorm.DB)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(string, *gorm.DB) error); ok {
		r1 = returnFunc(payload, query)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_UnscopedAssociation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UnscopedAssociation'
type MockAnyRepository_UnscopedAssociation_Call struct {
	*mock.Call
}

// UnscopedAssociation is a helper method to define mock.On call
//   - payload string
//   - query *gorm.DB
func (_e *MockAnyRepository_Expecter) UnscopedAssociation(payload interface{}, query interface{}) *MockAnyRepository_UnscopedAssociation_Call {
	return &MockAnyRepository_UnscopedAssociation_Call{Call: _e.mock.On("UnscopedAssociation", payload, query)}
}

func (_c *MockAnyRepository_UnscopedAssociation_Call) Run(run func(payload string, query *gorm.DB)) *MockAnyRepository_UnscopedAssociation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		var arg1 *gorm.DB
		if args[1] != nil {
			arg1 = args[1].(*gorm.DB)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAnyRepository_UnscopedAssociation_Call) Return(dB *gorm.DB, err error) *MockAnyRepository_UnscopedAssociation_Call {
	_c.Call.Return(dB, err)
	return _c
}

func (_c *MockAnyRepository_UnscopedAssociation_Call) RunAndReturn(run func(payload string, query *gorm.DB) (*gorm.DB, error)) *MockAnyRepository_UnscopedAssociation_Call {
	_c.Call.Return(run)
	return _c
}

// Update provides a mock function for the type MockAnyRepository
func (_mock *MockAnyRepository) Update(ctx *abstraction.Context, id int, model any) (any, error) {
	ret := _mock.Called(ctx, id, model)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 any
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, int, any) (any, error)); ok {
		return returnFunc(ctx, id, model)
	}
	if returnFunc, ok := ret.Get(0).(func(*abstraction.Context, int, any) any); ok {
		r0 = returnFunc(ctx, id, model)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(any)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(*abstraction.Context, int, any) error); ok {
		r1 = returnFunc(ctx, id, model)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAnyRepository_Update_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Update'
type MockAnyRepository_Update_Call struct {
	*mock.Call
}

// Update is a helper method to define mock.On call
//   - ctx *abstraction.Context
//   - id int
//   - model any
func (_e *MockAnyRepository_Expecter) Update(ctx interface{}, id interface{}, model interface{}) *MockAnyRepository_Update_Call {
	return &MockAnyRepository_Update_Call{Call: _e.mock.On("Update", ctx, id, model)}
}

func (_c *MockAnyRepository_Update_Call) Run(run func(ctx *abstraction.Context, id int, model any)) *MockAnyRepository_Update_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 *abstraction.Context
		if args[0] != nil {
			arg0 = args[0].(*abstraction.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 any
		if args[2] != nil {
			arg2 = args[2].(any)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAnyRepository_Update_Call) Return(v any, err error) *MockAnyRepository_Update_Call {
	_c.Call.Return(v, err)
	return _c
}

func (_c *MockAnyRepository_Update_Call) RunAndReturn(run func(ctx *abstraction.Context, id int, model any) (any, error)) *MockAnyRepository_Update_Call {
	_c.Call.Return(run)
	return _c
}
